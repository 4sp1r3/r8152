--- r8152_src/compatibility.h	2016-04-11 18:58:01.000000000 +0100
+++ r8152-2.05.0_esxi/compatibility.h	2016-04-11 19:59:28.000000000 +0100
@@ -33,13 +33,54 @@
 	#define USB_DEVICE_INTERFACE_CLASS(vend, prod, iclass) \
 		USB_DEVICE_AND_INTERFACE_INFO(vend, prod, iclass, 0xff, 0)
 
-	static inline __sum16 tcp_v6_check(int len,
-					   const struct in6_addr *saddr,
-					   const struct in6_addr *daddr,
-					   __wsum base)
-	{
-		return csum_ipv6_magic(saddr, daddr, len, IPPROTO_TCP, base);
-	}
+#if !defined(__VMKLNX__)
+        static inline __sum16 tcp_v6_check(int len,
+                                           const struct in6_addr *saddr,
+                                           const struct in6_addr *daddr,
+                                           __wsum base)
+        {
+                return csum_ipv6_magic(saddr, daddr, len, IPPROTO_TCP, base);
+        }
+#else
+        static inline __sum16 tcp_v6_check(int len,
+                                           struct in6_addr *saddr,
+                                           struct in6_addr *daddr,
+                                           __wsum base)
+        {
+                return csum_ipv6_magic(saddr, daddr, len, IPPROTO_TCP, base);
+        }
+
+#endif /* #if !defined(__VMKLNX__) */
+
+#if (VMWARE_ESX_DDK_VERSION <= 51000)
+
+/*
+ * New Feature Selectors as added by USB 3.0
+ * See USB 3.0 spec Table 9-6
+ */
+#define USB_DEVICE_U1_ENABLE    48      /* dev may initiate U1 transition */
+#define USB_DEVICE_U2_ENABLE    49      /* dev may initiate U2 transition */
+#define USB_DEVICE_LTM_ENABLE   50      /* dev may send LTM */
+#define USB_INTRF_FUNC_SUSPEND  0       /* function suspend */
+
+#define USB_INTR_FUNC_SUSPEND_OPT_MASK  0xFF00
+/*
+ * Suspend Options, Table 9-7 USB 3.0 spec
+ */
+#define USB_INTRF_FUNC_SUSPEND_LP       (1 << (8 + 0))
+#define USB_INTRF_FUNC_SUSPEND_RW       (1 << (8 + 1))
+
+/* Bit array elements as returned by the USB_REQ_GET_STATUS request. */
+#define USB_DEV_STAT_U1_ENABLED         2       /* transition into U1 state */
+#define USB_DEV_STAT_U2_ENABLED         3       /* transition into U2 state */
+#define USB_DEV_STAT_LTM_ENABLED        4       /* Latency tolerance messages */
+
+#endif /* #if (VMWARE_ESX_DDK_VERSION <= 51000) */
+
+#if defined(__VMKLNX__)
+u32 ethtool_op_get_rx_csum(struct net_device *dev);
+#endif /* #if !defined(__VMKLNX__) */
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0)
 	#define eth_random_addr(addr)			random_ether_addr(addr)
 	#define MDIO_EEE_100TX				MDIO_AN_EEE_ADV_100TX	/* 100TX EEE cap */
@@ -153,10 +194,13 @@
 	#define netif_info(priv, type, netdev, fmt, args...)		\
 		netif_printk(priv, type, KERN_INFO, (netdev), fmt, ##args)
 
+#if !defined(__VMKLNX__)
 	static inline int usb_enable_autosuspend(struct usb_device *udev)
 	{ return 0; }
 	static inline int usb_disable_autosuspend(struct usb_device *udev)
 	{ return 0; }
+#endif /* #if !defined(__VMKLNX__) */
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
 	#define get_sset_count				get_stats_count
 
@@ -183,49 +227,66 @@
 	#define pm_runtime_disable(para)
 	typedef int netdev_tx_t;
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)
-	#define USB_SPEED_SUPER				(USB_SPEED_VARIABLE + 1)
+
+#if !defined(__VMKLNX__)
+        #define USB_SPEED_SUPER                         (USB_SPEED_VARIABLE + 1)
+#else
+	#define USB_SPEED_SUPER				(USB_SPEED_WIRELESS + 1)
+#endif /* #if !defined(__VMKLNX__) */
+
 	#define MDIO_MMD_AN				7	/* Auto-Negotiation */
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
 	#define napi_gro_receive(napi, skb)		netif_receive_skb(skb)
 	#define vlan_gro_receive(napi, grp, vlan_tci, skb) \
 		vlan_hwaccel_receive_skb(skb, grp, vlan_tci)
 
-	static inline void usb_autopm_put_interface_async(struct usb_interface *intf)
-	{
-		struct usb_device *udev = interface_to_usbdev(intf);
-		int status = 0;
-
-		if (intf->condition == USB_INTERFACE_UNBOUND) {
-			status = -ENODEV;
-		} else {
-			udev->last_busy = jiffies;
-			--intf->pm_usage_cnt;
-			if (udev->autosuspend_disabled || udev->autosuspend_delay < 0)
-				status = -EPERM;
-		}
-	}
-
-	static inline int usb_autopm_get_interface_async(struct usb_interface *intf)
-	{
-		struct usb_device *udev = interface_to_usbdev(intf);
-		int status = 0;
-
-		if (intf->condition == USB_INTERFACE_UNBOUND)
-			status = -ENODEV;
-		else if (udev->autoresume_disabled)
-			status = -EPERM;
-		else
-			++intf->pm_usage_cnt;
-		return status;
-	}
-
-	static inline int eth_change_mtu(struct net_device *dev, int new_mtu)
+#if !defined(__VMKLNX__)
+        static inline void usb_autopm_put_interface_async(struct usb_interface *intf)
+        {
+                struct usb_device *udev = interface_to_usbdev(intf);
+                int status = 0;
+
+                if (intf->condition == USB_INTERFACE_UNBOUND) {
+                        status = -ENODEV;
+                } else {
+                        udev->last_busy = jiffies;
+                        --intf->pm_usage_cnt;
+                        if (udev->autosuspend_disabled || udev->autosuspend_delay < 0)
+                                status = -EPERM;
+                }
+        }
+
+        static inline int usb_autopm_get_interface_async(struct usb_interface *intf)
+        {
+                struct usb_device *udev = interface_to_usbdev(intf);
+                int status = 0;
+
+                if (intf->condition == USB_INTERFACE_UNBOUND)
+                        status = -ENODEV;
+                else if (udev->autoresume_disabled)
+                        status = -EPERM;
+                else
+                        ++intf->pm_usage_cnt;
+                return status;
+        }
+
+        static inline int eth_change_mtu(struct net_device *dev, int new_mtu)
+        {
+                if (new_mtu < 68 || new_mtu > ETH_DATA_LEN)
+                        return -EINVAL;
+                dev->mtu = new_mtu;
+                return 0;
+        }
+#else
+	static int eth_change_mtu(struct net_device *netdev, int new_mtu)
 	{
 		if (new_mtu < 68 || new_mtu > ETH_DATA_LEN)
 			return -EINVAL;
-		dev->mtu = new_mtu;
+		netdev->mtu = new_mtu;
 		return 0;
 	}
+#endif /* #if !defined(__VMKLNX__) */
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
 	static inline void __skb_queue_splice(const struct sk_buff_head *list,
 					      struct sk_buff *prev,
@@ -268,50 +329,59 @@
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)
 	#define PM_EVENT_AUTO		0x0400
 
-	static inline void __list_splice2(const struct list_head *list,
-					  struct list_head *prev,
-					  struct list_head *next)
-	{
-		struct list_head *first = list->next;
-		struct list_head *last = list->prev;
-
-		first->prev = prev;
-		prev->next = first;
+#if !defined(__VMKLNX__)
+        static inline void __list_splice2(const struct list_head *list,
+                                          struct list_head *prev,
+                                          struct list_head *next)
+        {
+                struct list_head *first = list->next;
+                struct list_head *last = list->prev;
+
+                first->prev = prev;
+                prev->next = first;
+
+                last->next = next;
+                next->prev = last;
+        }
+
+        static inline void list_splice_tail(struct list_head *list,
+                                            struct list_head *head)
+        {
+                if (!list_empty(list))
+                        __list_splice2(list, head->prev, head);
+        }
+#endif /* !defined(__VMKLNX__) */
 
-		last->next = next;
-		next->prev = last;
-	}
-
-	static inline void list_splice_tail(struct list_head *list,
-					    struct list_head *head)
-	{
-		if (!list_empty(list))
-			__list_splice2(list, head->prev, head);
-	}
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
-	struct napi_struct {
-		struct list_head	poll_list;
-		unsigned long		state;
-		int			weight;
-		int			(*poll)(struct napi_struct *, int);
-	#ifdef CONFIG_NETPOLL
-		spinlock_t		poll_lock;
-		int			poll_owner;
-		struct net_device	*dev;
-		struct list_head	dev_list;
-	#endif
-	};
 
-	#define napi_enable(napi_ptr)			netif_poll_enable(container_of(napi_ptr, struct r8152, napi)->netdev)
-	#define napi_disable(napi_ptr)			netif_poll_disable(container_of(napi_ptr, struct r8152, napi)->netdev)
-	#define napi_schedule(napi_ptr)			netif_rx_schedule(container_of(napi_ptr, struct r8152, napi)->netdev)
-	#define napi_complete(napi_ptr)			netif_rx_complete(container_of(napi_ptr, struct r8152, napi)->netdev)
+#if !defined(__VMKLNX__)
+        struct napi_struct {
+                struct list_head        poll_list;
+                unsigned long           state;
+                int                     weight;
+                int                     (*poll)(struct napi_struct *, int);
+        #ifdef CONFIG_NETPOLL
+                spinlock_t              poll_lock;
+                int                     poll_owner;
+                struct net_device       *dev;
+                struct list_head        dev_list;
+        #endif
+        };
+
+	#define napi_enable(napi_ptr)            netif_poll_enable(container_of(napi_ptr, struct r8152, napi)->netdev)
+	#define napi_disable(napi_ptr)            netif_poll_disable(container_of(napi_ptr, struct r8152, napi)->netdev)
+	#define napi_schedule(napi_ptr)            netif_rx_schedule(container_of(napi_ptr, struct r8152, napi)->netdev)
+	#define napi_complete(napi_ptr)            netif_rx_complete(container_of(napi_ptr, struct r8152, napi)->netdev)
 	#define netif_napi_add(ndev, napi_ptr, function, weight_t) \
-		ndev->poll = function; \
-		ndev->weight = weight_t;
+        ndev->poll = function; \
+        ndev->weight = weight_t;
+	typedef unsigned long				uintptr_t;
+        #define DMA_BIT_MASK(value) \
+                (value < 64 ? ((1ULL << value) - 1) : 0xFFFFFFFFFFFFFFFFULL)
+#else
 	typedef unsigned long				uintptr_t;
-	#define DMA_BIT_MASK(value) \
-		(value < 64 ? ((1ULL << value) - 1) : 0xFFFFFFFFFFFFFFFFULL)
+#endif /* !defined(__VMKLNX__) */
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
 	#define NETIF_F_IPV6_CSUM			16
 	#define cancel_delayed_work_sync		cancel_delayed_work
@@ -332,31 +402,41 @@
 	#define ip_hdr(skb_ptr)				(skb_ptr)->nh.iph
 	#define ipv6hdr(skb_ptr)			(skb_ptr)->nh.ipv6h
 
-	static inline void skb_copy_from_linear_data(const struct sk_buff *skb,
-						     void *to,
-						     const unsigned int len)
-	{
-		memcpy(to, skb->data, len);
-	}
+#if !defined(__VMKLNX__)
+        static inline void skb_copy_from_linear_data(const struct sk_buff *skb,
+                                                     void *to,
+                                                     const unsigned int len)
+        {
+                memcpy(to, skb->data, len);
+        }
+#endif /* #if !defined(__VMKLNX__) */
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21)
 	#define vlan_group_set_device(vlgrp, vid, value) \
 		if (vlgrp) \
 			(vlgrp)->vlan_devices[vid] = value;
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+
+#if !defined(__VMKLNX__)
 	#define delayed_work				work_struct
-	#define INIT_DELAYED_WORK(a,b)			INIT_WORK(a,b,tp)
+        #define INIT_DELAYED_WORK(a,b)                  INIT_WORK(a,b,tp)
+#endif /* #if !defined(__VMKLNX__) */
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
-	#define CHECKSUM_PARTIAL			CHECKSUM_HW
+#if !defined(__VMKLNX__)
+        #define CHECKSUM_PARTIAL                        CHECKSUM_HW
 
-	static inline void *kmemdup(const void *src, size_t len, gfp_t gfp)
-	{
-		void *p;
+        static inline void *kmemdup(const void *src, size_t len, gfp_t gfp)
+        {
+                void *p;
+
+                p = kmalloc_track_caller(len, gfp);
+                if (p)
+                        memcpy(p, src, len);
+                return p;
+        }
+#endif /* #if !defined(__VMKLNX__) */
 
-		p = kmalloc_track_caller(len, gfp);
-		if (p)
-			memcpy(p, src, len);
-		return p;
-	}
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
 	#define skb_is_gso(skb_ptr)			skb_shinfo(skb_ptr)->tso_size
 	#define netdev_alloc_skb(dev, len)		dev_alloc_skb(len)
@@ -390,12 +470,21 @@
 #endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22) */
 #endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23) */
 #endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24) */
-	static inline void netif_napi_del(struct napi_struct *napi)
-	{
-	#ifdef CONFIG_NETPOLL
-	        list_del(&napi->dev_list);
-	#endif
-	}
+#if !defined(__VMKLNX__)
+        static inline void netif_napi_del(struct napi_struct *napi)
+        {
+        #ifdef CONFIG_NETPOLL
+                list_del(&napi->dev_list);
+        #endif
+        }
+#else
+        void netif_napi_del(struct napi_struct *napi)
+        {
+        #ifdef CONFIG_NETPOLL
+                list_del(&napi->dev_list);
+        #endif
+        }
+#endif /* #if !defined(__VMKLNX__) */
 #endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27) */
 #endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28) */
 #endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29) */
